<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Idol Explorer — Minu’s Robotics & Coding</title>
  <style>
    :root {
      --accent: #ff6f00;
      --muted: #6b7280
    }

    body {
      margin: 0;
      font-family: Inter, Arial, system-ui;
      background: linear-gradient(180deg, #fff7ed, #fff1e6);
      color: #071122;
      display: flex;
      justify-content: center;
      padding: 18px
    }

    .wrap {
      width: 100%;
      max-width: 1100px
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap
    }

    .titleSmall {
      color: var(--muted);
      font-size: 13px
    }

    .controls {
      display: flex;
      gap: 10px;
      align-items: center
    }

    .desktopControls {
      display: flex;
      gap: 8px;
      align-items: center
    }

    .alwaysVisible {
      display: flex;
      gap: 8px;
      align-items: center
    }

    .btn {
      background: var(--accent);
      color: #fff;
      padding: 10px 14px;
      border-radius: 12px;
      border: none;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.12)
    }

    select {
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid #e6e6e6
    }

    input[type="text"] {
      padding: 8px;
      border-radius: 8px;
      border: 1px solid #eee
    }

    .card {
      background: #fff;
      border-radius: 14px;
      padding: 16px;
      margin-top: 12px;
      box-shadow: 0 10px 30px rgba(2, 6, 23, 0.06)
    }

    .idolWrap {
      position: relative;
      width: 100%;
      border-radius: 14px;
      /* slightly larger radius for a softer card look */
      overflow: hidden;
      background: linear-gradient(180deg, #fff6ef, #fff1e6);
      /* warm paper tone */
      box-shadow: 0 20px 45px rgba(8, 12, 20, 0.08);
      border: 1px solid rgba(0, 0, 0, 0.04);
    }

    #imgWrap {
      position: relative;
      width: 100%;
      height: min(72vh, 760px);
      /* keeps composition tall on desktop, not enormous */
      padding: 0;
      /* remove extra padding so cover fills */
      display: block;
    }


    /* Make idol always cover the frame (like background-size:cover) */
    #idol {
      display: block;
      width: 100%;
      height: 100%;
      object-fit: cover;
      /* IMPORTANT: makes image cover and crop nicely */
      object-position: center 38%;
      /* shift focal area slightly upward — tweak as needed */
      -webkit-filter: saturate(1.02) contrast(1.02);
      /* subtle pop */
      filter: saturate(1.02) contrast(1.02);
    }

    .hotspot {
      position: absolute;
      transform: translate(-50%, -50%);
      width: 56px;
      height: 56px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 60
    }

    .hsdot {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: linear-gradient(90deg, var(--accent), #ffb74d);
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 6px 18px rgba(255, 152, 0, 0.12);
      animation: pulse 1.8s infinite
    }

    .hsdot img {
      width: 26px;
      height: 26px
    }

    @keyframes dissolve {
      0% {
        opacity: 1
      }

      100% {
        opacity: 0
      }

    }

    @keyframes pulse {
      0% {
        transform: scale(1);
        opacity: 1
      }

      50% {
        transform: scale(1.12);
        opacity: 0.75
      }

      100% {
        transform: scale(1);
        opacity: 1
      }
    }

    .hotspot.touched .hsdot {
      animation: dissolve 8.6s forwards;
      opacity: 0.9
    }

    .collection {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 12px
    }

    .badge {
      background: #fff;
      padding: 6px 10px;
      border-radius: 8px;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 8px;
      border: 1px solid #f1e0d0
    }

    .badge.demon {
      border-color: rgba(255, 80, 80, 0.12);
      background: linear-gradient(90deg, #fff7f7, #fff1f1);
      color: #7a0b0b
    }

    .footer {
      margin-top: 14px;
      color: var(--muted);
      font-size: 13px;
      text-align: center
    }

    .confettiWrap {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 600;
      display: none
    }

    .particle {
      position: absolute;
      font-size: 28px;
      animation: fall 3.2s linear forwards;
      opacity: 0.95
    }

    @keyframes fall {
      0% {
        transform: translateY(-20vh) rotate(0deg);
        opacity: 1
      }

      100% {
        transform: translateY(110vh) rotate(720deg);
        opacity: 0
      }
    }

    .quizPopup {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      background: #fff;
      color: #071122;
      padding: 16px;
      border-radius: 12px;
      box-shadow: 0 20px 50px rgba(2, 6, 23, 0.15);
      display: none;
      z-index: 700
    }

    .quizPopup button {
      margin-top: 8px;
      background: var(--accent);
      border: none;
      padding: 8px 10px;
      color: white;
      border-radius: 8px;
      cursor: pointer
    }

    .langIndicator {
      margin-left: 8px;
      padding: 6px 8px;
      border-radius: 8px;
      font-weight: 700;
      font-size: 12px;
      background: #fff4f4;
      color: #8b0000;
      border: 1px solid rgba(0, 0, 0, 0.04)
    }

    .toast {
      position: fixed;
      right: 16px;
      bottom: 18px;
      background: rgba(2, 6, 23, 0.92);
      color: #fff;
      padding: 10px 14px;
      border-radius: 8px;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.25);
      z-index: 9999;
      font-weight: 700;
      opacity: 0;
      transform: translateY(8px);
      transition: .28s
    }

    .toast.show {
      opacity: 1;
      transform: translateY(0)
    }

    /* Orientation overlay: center the GIF and dim nicely */
    #orientationOverlay {
      position: fixed;
      inset: 0;
      display: none;
      /* keep default - toggled in JS */
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.72);
      z-index: 1000;
      color: #fff;
      text-align: center;
      padding: 28px;
      backdrop-filter: blur(4px);
    }

    #orientationOverlay img {
      max-width: 340px;
      width: 60%;
      height: auto;
    }

    /* Make caption/footer a little cleaner and more compact */
    .footer {
      margin-top: 16px;
      color: var(--muted);
      font-size: 13px;
      text-align: center;
      opacity: 0.9;
    }

    /* Slightly reduce the heavy global card shadow so the idol shines */
    .card {
      box-shadow: 0 12px 30px rgba(2, 6, 23, 0.06);
    }

    /* mobile overlay buttons (appear only on small screens) */
    .overlayButtons {
      display: none;
      position: absolute;
      top: 10px;
      z-index: 90;
      pointer-events: auto
    }

    .overlayButtons.left {
      left: 10px;
      flex-direction: column;
      gap: 8px;
      align-items: flex-start
    }

    .overlayButtons.right {
      right: 10px;
      flex-direction: column;
      gap: 8px;
      align-items: flex-end
    }

    .overlayButtons .btn {
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 13px
    }

    /* selfie modal */
    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999
    }

    .popupCard {
      background: #fff;
      padding: 12px;
      border-radius: 12px;
      text-align: center;
      position: relative;
      max-width: 96%;
    }

    .popupCard video {
      max-width: 420px;
      border-radius: 8px;
      width: 100%;
      height: 30%;
    }


    /* Selfie preview shown after composite: make it large, crisp and readable */
    .selfiePreview img {
      max-width: 420px;
      width: 36vw;
      max-height: 420px;
      border-radius: 999px;
      /* perfect circle */
      border: 6px solid rgba(255, 255, 255, 0.95);
      /* strong white ring for contrast on dark selfies */
      box-shadow: 0 18px 40px rgba(6, 12, 30, 0.32);
      display: block;
      margin: 18px auto 8px;
      object-fit: cover;
      background: #000;
      /* fallback for dark selfies */
    }

    .closeBtn {
      position: absolute;
      top: 8px;
      right: 8px;
      background: #ff4d4d;
      color: #fff;
      border: none;
      padding: 6px 10px;
      border-radius: 50%;
      cursor: pointer;
      font-weight: 800;
      z-index: 2000;
    }

    /* desktop-only area (hidden on small screen) */
    .desktopOnly {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-top: 12px
    }

    /* RESPONSIVE */
    @media(max-width:768px) {
      .desktopControls {
        display: none
      }

      .overlayButtons {
        display: flex
      }

      .desktopOnly {
        display: none
      }

      .titleSmall {
        font-size: 12px
      }

      .header {
        align-items: flex-start
      }
    }
  </style>
</head>



<body>
  <div id="orientationOverlay" style="position:fixed;inset:0;display:none;z-index:1000;">
    <img src="assets/rotate.gif" alt="Rotate device" style="width:100%;height:auto;margin-bottom:20px" />

  </div>

  <div class="wrap">
    <div class="header">
      <div>
        <h1 id="siteTitle" style="margin:0;font-size:18px">Idol Explorer — Festive Learning with Minu’s Robotics &
          Coding</h1>
        <div class="titleSmall">Make &lt;Code/&gt; Play. Explore Gods, Attributes & Vahaans.</div>
      </div>

      <div class="controls">
        <div class="alwaysVisible">
          <select id="langSel" aria-label="Language">
            <option value="en">English</option>
            <option value="hi">हिन्दी</option>
            <option value="bn">বাংলা</option>
          </select>
          <span id="voiceIndicator" class="langIndicator">checking…</span>
        </div>

        <div class="desktopControls">
          <button class="btn" id="modeSawari">Discover Vahaans</button>
          <button class="btn" id="modeWeapons">Shakti &amp; Symbols</button>
          <button class="btn" id="modeGods">Name the Gods</button>
          <button class="btn" id="modeDemons">Meet Demon</button>
          <input id="childName" type="text" placeholder="Child name (optional)"
            style="padding:8px;border-radius:8px;border:1px solid #eee" />
          <button class="btn" id="downloadCert">Download Certificate</button>
          <button id="startAudio">Start Dhak</button>

        </div>
      </div>
    </div>

    <div class="card">
      <div class="idolWrap">
        <!-- Mobile overlay: left (modes) and right (utilities) -->
        <div class="overlayButtons left" aria-hidden="true">
          <button class="btn" id="modeSawari_mobile">Discover Vahaans</button>
          <button class="btn" id="modeWeapons_mobile">Shakti &amp; Symbols</button>
          <button class="btn" id="modeGods_mobile">Name the Gods</button>
        </div>
        <div class="overlayButtons right" aria-hidden="true">
          <button class="btn" id="downloadCert_mobile">Certificate</button>
          <button class="btn" id="selfieBtn_mobile">Selfie</button>
          <button class="btn" id="shareBtn_mobile">Share</button>
        </div>

        <div id="imgWrap">
          <img id="idol" src="assets/durga_idol.jpg" alt="Durga Idol">
        </div>
      </div>

      <div style="margin-top:12px;display:flex;align-items:center;gap:12px">
        <div style="font-weight:800">Mode: <span id="currentMode">Sawari</span></div>
        <div style="flex:1;background:#eef2f7;height:12px;border-radius:999px;overflow:hidden">
          <div id="progressFill" style="height:100%;width:0;background:linear-gradient(90deg,#ffb74d,var(--accent))">
          </div>
        </div>
        <div id="progressCount" style="min-width:80px;text-align:right;font-weight:700">0 / 0</div>
      </div>

      <div class="collection" id="collectionArea" aria-live="polite"></div>

      <!-- Desktop-only selfie/share (hidden on mobile) -->
      <div class="desktopOnly">
        <button class="btn" id="selfieBtn">Take Selfie & Overlay</button>
        <button class="btn" id="shareBtn">Download & Share</button>
      </div>

      <div class="selfiePreview" id="selfiePreview" aria-hidden="true"></div>
      <div class="footer">Powered by <a href="https://minugames.com" target="_blank">Minu’s Robotics &amp; Coding
          Center, Kishanganj</a> | Coding Sikho — Future Banao</div>
    </div>

  </div>

  <div class="confettiWrap" id="confettiWrap"></div>

  <!-- Quiz popup -->
  <div class="quizPopup" id="quizPopup">
    <div id="quizQ" style="font-weight:900"></div>
    <div style="margin-top:8px"><button id="optA"></button><button id="optB" style="margin-left:8px"></button></div>
    <div style="margin-top:10px;text-align:right"><button onclick="closeQuiz()"
        style="background:#eee;padding:8px;border-radius:8px;border:none">Close</button></div>
  </div>

  <!-- Selfie overlay modal (persistent in DOM so we can reuse) -->
  <div class="overlay" id="selfieOverlay" aria-hidden="true">
    <div class="popupCard" role="dialog" aria-modal="true">
      <button id="closeSelfie" class="closeBtn" aria-label="Close selfie modal">×</button>
      <video id="selfieVideo" autoplay playsinline></video>
      <div style="margin-top:8px">
        <button class="btn" id="captureSelfie">Capture</button>
      </div>
    </div>
  </div>

  <div id="toastRoot"></div>


  <script>
    /* CONFIG */
    const DHAK_URL = 'assets/audio/dhak_loop.mp3'; // background loop
    const DUCK_VOLUME = 0.02;      // volume while narration plays (0-1)
    const NORMAL_VOLUME = 0.10;    // normal background volume (0-1)
    const FADE_TIME = 0.25;        // seconds to fade in/out
    /* END CONFIG */

    let audioCtx, dhakSource, dhakGain;
    const narrationElements = {}; // cache for HTMLAudioElements (per item)

    /* create AudioContext and start dhak loop */
    async function initAudio() {
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      // create dhak audio element (loop)
      const dhakEl = new Audio(DHAK_URL);
      dhakEl.loop = true;
      await dhakEl.load();

      // create media source and gain node
      dhakSource = audioCtx.createMediaElementSource(dhakEl);
      dhakGain = audioCtx.createGain();
      dhakGain.gain.value = NORMAL_VOLUME;

      // connect: dhak -> gain -> destination
      dhakSource.connect(dhakGain).connect(audioCtx.destination);

      // start playing (user gesture required -> startAudio button)
      dhakEl.play().catch(e => console.warn('play blocked', e));

      // keep element reference so we can stop if needed
      dhakEl._isDhak = true;
      window.__dhakEl = dhakEl;
    }

    /* Play narration for an item (id: e.g. 'lion') and duck dhak automatically */
    function playNarration(id, srcUrl) {
      // ensure AudioContext exists
      if (!audioCtx) {
        console.warn('Audio not initialized. Call initAudio() first.');
        return;
      }

      // create or reuse HTMLAudioElement for narration
      let el = narrationElements[id];
      if (!el) {
        el = new Audio(srcUrl);
        el.preload = 'auto';
        narrationElements[id] = el;

        // Create and connect a media element source so its playback uses the same AudioContext
        const src = audioCtx.createMediaElementSource(el);
        // If you want further control over narration volume you can add a gain node:
        const narrationGain = audioCtx.createGain();
        narrationGain.gain.value = 1.0;
        src.connect(narrationGain).connect(audioCtx.destination);
      } else {
        el.src = srcUrl; // in case you passed different language etc
      }

      // fade background down
      const now = audioCtx.currentTime;
      dhakGain.gain.cancelScheduledValues(now);
      dhakGain.gain.setValueAtTime(dhakGain.gain.value, now);
      dhakGain.gain.linearRampToValueAtTime(DUCK_VOLUME, now + FADE_TIME);

      // play narration
      el.currentTime = 0;
      el.play().catch(e => console.warn('narration play blocked', e));

      // when narration ends, restore dhak volume
      el.onended = () => {
        const t = audioCtx.currentTime;
        dhakGain.gain.cancelScheduledValues(t);
        dhakGain.gain.setValueAtTime(dhakGain.gain.value, t);
        dhakGain.gain.linearRampToValueAtTime(NORMAL_VOLUME, t + FADE_TIME);
      };
    }

    /* Hook start button (user gesture required by many browsers) */
    document.getElementById('startAudio').addEventListener('click', async () => {
      await initAudio();
      // resume context on browsers that start it suspended
      if (audioCtx.state === 'suspended') await audioCtx.resume();

      // hide the button if you like


      // document.getElementById('startAudio').innerHTML == 'Start Dhak' ? 'Stop Dhak' : 'Start Dhak';
      if (window.__dhakEl) {
        if (window.__dhakEl.paused) {
          window.__dhakEl.play();
          document.getElementById('startAudio').innerHTML = 'Stop Dhak';
        } else {
          window.__dhakEl.pause();
          document.getElementById('startAudio').innerHTML = 'Start Dhak';
        }
      }


    });


    /* Example: attach to pointer events (replace with your pointer logic)
       Suppose each interactive icon has data-audio attribute with the narration path.
    */
    document.addEventListener('click', (e) => {
      const el = e.target.closest('[data-narration]');
      if (!el) return;
      const id = el.dataset.id || 'item';
      const src = el.datasetNarration || el.dataset.narration; // depends how you set it
      // play narration, dhak will duck automatically
      playNarration(id, src);
    });
  </script>


  <script>
    /* -----------------------
       Utilities & state
       ----------------------- */
    let HOTSPOTS = {};
    let mode = 'sawari';
    let found = { sawari: new Set(), weapons: new Set(), gods: new Set(), demons: new Set() };
    let lastComposite = null;
    let lastCompositeBlob = null;
    let audioEl = new Audio(); audioEl.preload = 'auto'; audioEl.crossOrigin = 'anonymous';

    function $(id) { return document.getElementById(id); }
    function showToast(msg, timeout = 3000) {
      const el = document.createElement('div'); el.className = 'toast'; el.textContent = msg;
      document.body.appendChild(el);
      requestAnimationFrame(() => el.classList.add('show'));
      setTimeout(() => { el.classList.remove('show'); setTimeout(() => el.remove(), 300); }, timeout);
    }

    /* -----------------------
       Voice / TTS helpers
       ----------------------- */
    let AVAILABLE_VOICES = [];
    function refreshVoices() { AVAILABLE_VOICES = window.speechSynthesis.getVoices() || []; updateVoiceIndicator(); }
    if ('speechSynthesis' in window) { refreshVoices(); window.speechSynthesis.onvoiceschanged = refreshVoices; setTimeout(refreshVoices, 400); }
    function pickVoiceForLang(langCode) {
      if (!AVAILABLE_VOICES.length) return null;
      const pref = (langCode === 'hi') ? 'hi' : (langCode === 'bn') ? 'bn' : 'en';
      let v = AVAILABLE_VOICES.find(vc => vc.lang && vc.lang.toLowerCase().startsWith(pref));
      if (!v) v = AVAILABLE_VOICES.find(vc => vc.lang && vc.lang.toLowerCase().includes(pref));
      return v || null;
    }
    function sanitizeForTTS(text) {
      if (!text) return text;
      return text.replace(/;/g, ',').replace(/:/g, ',').replace(/\n+/g, ' ').replace(/\r/g, ' ').replace(/\s{2,}/g, ' ').trim();
    }
    function speakText(text, lang) {
      try {
        if (!text) return;
        if (!('speechSynthesis' in window)) return;
        const code = lang || 'en';
        const clean = sanitizeForTTS(text);
        const u = new SpeechSynthesisUtterance(clean);
        const v = pickVoiceForLang(code);
        if (v) { u.voice = v; u.lang = v.lang || (code === 'hi' ? 'hi-IN' : code === 'bn' ? 'bn-IN' : 'en-IN'); }
        else { u.lang = (code === 'hi' ? 'hi-IN' : code === 'bn' ? 'bn-IN' : 'en-IN'); }
        u.rate = 0.95; u.pitch = 1.0;
        window.speechSynthesis.cancel(); window.speechSynthesis.speak(u);
      } catch (e) { console.error('TTS error', e); }
    }
    function updateVoiceIndicator() {
      const ind = $('voiceIndicator'); if (!ind) return;
      const lang = ($('langSel') && $('langSel').value) ? $('langSel').value : 'en';
      const v = pickVoiceForLang(lang);
      if (v) { ind.textContent = lang.toUpperCase() + ' voice ✓'; ind.style.background = '#e6ffed'; ind.style.color = '#0b6b2f'; }
      else { ind.textContent = lang.toUpperCase() + ' voice ✕ (fallback)'; ind.style.background = '#fff4f4'; ind.style.color = '#8b0000'; }
    }
    document.addEventListener('change', (e) => { if (e.target && e.target.id === 'langSel') { updateVoiceIndicator(); } });

    /* -----------------------
       Audio helpers
       ----------------------- */
    function computedAudioPath(hotspotId, lang) {
      const safeId = encodeURIComponent(hotspotId);
      const safeLang = (lang === 'hi' || lang === 'bn') ? lang : 'en';
      return `assets/audio/${safeId}_${safeLang}.wav`;
    }
    function getAudioFromHotspot(h, lang) {
      if (h && h.audio) {
        if (h.audio[lang]) return h.audio[lang];
        if (h.audio['en']) return h.audio['en'];
        const keys = Object.keys(h.audio || {});
        if (keys.length) return h.audio[keys[0]];
      }
      return computedAudioPath(h.id, lang);
    }
    async function tryPlayUrl(url) {
      if (!url) return false;
      try {
        audioEl.pause(); audioEl.src = url; audioEl.currentTime = 0;
        try { await audioEl.load(); } catch (e) { }
        await audioEl.play();
        return true;
      } catch (e) {
        console.warn('Audio play failed for', url, e);
        return false;
      }
    }

    /* -----------------------
       Hotspots / UI
       ----------------------- */
    function getTextFor(h) {
      const lang = ($('langSel') && $('langSel').value) ? $('langSel').value : 'en';
      if (lang === 'hi') return { label: h.label_hi || h.label_en || h.label || h.id, story: h.story_hi || h.story_en || h.story || '' };
      if (lang === 'bn') return { label: h.label_bn || h.label_en || h.label || h.id, story: h.story_bn || h.story_en || h.story || '' };
      return { label: h.label_en || h.label || h.id, story: h.story_en || h.story || '' };
    }

    function makeHotspot(h) {
      const el = document.createElement('div'); el.className = 'hotspot';
      el.style.left = (h.x * 100) + '%'; el.style.top = (h.y * 100) + '%';
      const dot = document.createElement('div'); dot.className = 'hsdot';
      const img = document.createElement('img'); img.src = h.icon || 'assets/lion.png'; img.alt = h.id || '';
      dot.appendChild(img); el.appendChild(dot);
      el.addEventListener('click', async (ev) => {
        ev.stopPropagation();
        el.classList.add('touched'); // stop the pulse
        await onHotspotClick(h, el);
      });
      return el;
    }

    function renderHotspots() {
      const wrap = $('imgWrap');
      if (!wrap) return;
      wrap.querySelectorAll('.hotspot').forEach(n => n.remove());
      const list = HOTSPOTS[mode] || [];
      list.forEach(h => {
        try { wrap.appendChild(makeHotspot(h)); } catch (e) { console.warn('hotspot render err', e) }
      });
      updateProgress();
    }

    async function onHotspotClick(h, el) {
      const t = getTextFor(h);
      const selectedLang = ($('langSel') && $('langSel').value) ? $('langSel').value : 'en';

      // small floating popup near hotspot
      const popup = document.createElement('div');
      popup.style.position = 'absolute';
      console.log(h.x * 100);
      if (h.x * 100 < 50) {
        popup.style.left = (h.x * 100 + 10) + '%';
      }
      else {
        popup.style.left = (h.x * 100 - 10) + '%';
      }
      // popup.style.left = (h.x * 100) + '%';
      // popup.style.transform = 'translateX(-50%)';
      popup.style.top = (Math.max(0, h.y * 100 - 6)) + '%';
      popup.style.transform = 'translate(-50%,-100%)';
      popup.style.background = '#fff';
      popup.style.color = '#071122';
      popup.style.padding = '10px';
      // popup.style.marginLeft = '150px';
      popup.style.borderRadius = '8px';
      popup.style.maxWidth = '220px';
      popup.style.minHeight = '80px';
      popup.style.boxShadow = '0 8px 24px rgba(2,6,23,0.12)';
      popup.style.zIndex = '60';
      popup.innerHTML = `<strong>${escapeHtml(t.label)}</strong><div style="font-size:13px;margin-top:6px">${escapeHtml(t.story)}</div>`;
      $('imgWrap').appendChild(popup);
      setTimeout(() => popup.remove(), 8200);

      // try audio file first (explicit or computed)
      let played = false;
      try {
        const candidate = getAudioFromHotspot(h, selectedLang);
        if (candidate) played = await tryPlayUrl(candidate);
      } catch (e) { console.warn(e) }

      // fallback english audio
      if (!played && selectedLang !== 'en') {
        const enCandidate = getAudioFromHotspot(h, 'en');
        if (enCandidate) played = await tryPlayUrl(enCandidate);
      }

      // fallback TTS
      if (!played) {
        const v = pickVoiceForLang(selectedLang);
        if (!v) showToast(selectedLang.toUpperCase() + ' voice not available — using fallback');
        speakText(t.story, selectedLang);
      }

      markFound(h);
    }

    function escapeHtml(str) {
      if (!str) return '';
      return str.replace(/[&<>"']/g, s => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[s]));
    }

    /* -----------------------
       Progress / badges / quiz / celebration
       ----------------------- */
    function markFound(h) {
      if (found[mode].has(h.id)) return;
      found[mode].add(h.id);
      addBadge(h);
      updateProgress();
      if (found[mode].size >= (HOTSPOTS[mode] || []).length) {
        celebrate();
        setTimeout(() => openQuizForMode(mode), 2500);
      }
    }

    function addBadge(h) {
      const key = mode + '-' + h.id;
      if (document.getElementById(key)) return;
      const b = document.createElement('div'); b.className = 'badge' + (h.type === 'demon' ? ' demon' : ''); b.id = key;
      const t = getTextFor(h);
      const extra = (h.type === 'demon') ? '<span title="Demon" style="margin-right:6px;font-weight:900;color:#c62828">⚠</span>' : '';
      b.innerHTML = extra + `<img src="${h.icon || ''}" style="width:28px;height:28px;border-radius:6px;margin-right:8px"/>` + escapeHtml(t.label);
      $('collectionArea').appendChild(b);
    }

    function updateProgress() {
      const got = found[mode].size;
      const total = (HOTSPOTS[mode] || []).length;
      const pct = total ? (got / total * 100) : 0;
      $('progressFill').style.width = pct + '%';
      $('progressCount').textContent = got + ' / ' + total;
      $('currentMode').textContent = capitalize(mode);
    }

    function capitalize(s) { if (!s) return s; return s.charAt(0).toUpperCase() + s.slice(1); }

    function celebrate() {
      const wrap = $('confettiWrap'); wrap.innerHTML = ''; wrap.style.display = 'block';
      const colors = ['#ff5252', '#ffd54a', '#4dd0e1', '#a5d6a7', '#ce93d8'];
      for (let i = 0; i < 20; i++) {
        const p = document.createElement('div'); p.className = 'particle';
        p.style.left = (Math.random() * 100) + '%'; p.style.top = '-10%';
        p.style.color = colors[i % colors.length]; p.style.fontSize = (12 + Math.random() * 28) + 'px';
        p.textContent = ['🎉', '✨', '🎊', '🍃', '🪔'][i % 5]; p.style.animationDuration = (2.5 + Math.random() * 1.5) + 's';
        wrap.appendChild(p);
      }
      setTimeout(() => { wrap.innerHTML = ''; wrap.style.display = 'none'; }, 3600);
    }

    function openQuizForMode(m) {
      let q;
      if (m === 'demons') q = { q: 'Who defeated Mahishasura?', a: 'Maa Durga', b: 'Ganesha', ans: 'Maa Durga' };
      else if (m === 'sawari') q = { q: 'Who rides the peacock?', a: 'Kartikeya', b: 'Lakshmi', ans: 'Kartikeya' };
      else if (m === 'weapons' || m === 'attributes') q = { q: 'What does the Trishul destroy?', a: 'Evil', b: 'Flowers', ans: 'Evil' };
      else q = { q: 'Who is the goddess of knowledge?', a: 'Saraswati', b: 'Lakshmi', ans: 'Saraswati' };
      $('quizQ').textContent = q.q; $('optA').textContent = q.a; $('optB').textContent = q.b;
      $('optA').onclick = () => checkQuiz(q.a, q.ans); $('optB').onclick = () => checkQuiz(q.b, q.ans);
      $('quizPopup').style.display = 'block';
    }
    function checkQuiz(choice, ans) { if (choice === ans) showToast('Correct! Bonus unlocked.'); else showToast('Not quite — try another mode!'); closeQuiz(); }
    function closeQuiz() { $('quizPopup').style.display = 'none' }

    /* -----------------------
       Certificate & sharing helpers
       ----------------------- */
    function dataURLToBlob(dataURL) {
      const parts = dataURL.split(',');
      const meta = parts[0].match(/:(.*?);/);
      const mime = meta ? meta[1] : 'image/png';
      const bstr = atob(parts[1]); let n = bstr.length; const u8 = new Uint8Array(n);
      while (n--) u8[n] = bstr.charCodeAt(n);
      return new Blob([u8], { type: mime });
    }
    async function saveBlobAsFile(blob, filename = 'file.png') {
      try {
        const file = new File([blob], filename, { type: blob.type });
        if (navigator.canShare && navigator.canShare({ files: [file] })) {
          await navigator.share({ files: [file], title: filename, text: 'Sharing from Idol Explorer' });
          return { method: 'share' };
        }
      } catch (e) { console.warn('Web Share failed', e) }
      try {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 15000);
        return { method: 'download' };
      } catch (e) { console.warn('anchor download failed', e) }
      try { const url = URL.createObjectURL(blob); window.open(url, '_blank'); setTimeout(() => URL.revokeObjectURL(url), 30000); return { method: 'open' } }
      catch (e) { console.warn('final open failed', e); return { method: 'none' } }
    }

    async function downloadCertificate() {
      const child = ($('childName') && $('childName').value) ? $('childName').value : 'Young Explorer';
      const c = document.createElement('canvas'); c.width = 1200; c.height = 675; const ctx = c.getContext('2d');
      ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, c.width, c.height); ctx.fillStyle = '#071122';
      ctx.font = '36px sans-serif'; ctx.fillText('Certificate of Exploration', 50, 70);
      ctx.font = '24px sans-serif'; ctx.fillText('Awarded to: ' + child, 50, 120);
      ctx.font = '18px sans-serif'; ctx.fillText('Badges:', 50, 160);
      let y = 200;
      const items = Array.from($('collectionArea').children).map(c => c.textContent.trim());
      if (items.length) { ctx.font = '20px sans-serif'; items.forEach(it => { ctx.fillText('• ' + it, 60, y); y += 34; }); }
      else { ctx.fillStyle = '#444'; ctx.font = '18px sans-serif'; ctx.fillText('No badges collected yet.', 50, y); }
      ctx.fillStyle = '#666'; ctx.font = '14px sans-serif'; ctx.fillText("Minu's Robotics & Coding - Happy Puja!", 50, c.height - 40);
      const dataURL = c.toDataURL('image/png'); const blob = dataURLToBlob(dataURL); const filename = 'certificate-' + child.replace(/\s+/g, '_') + '.png';
      const result = await saveBlobAsFile(blob, filename);
      if (result.method === 'open') showToast('Opened in new tab — long-press image to save.');
      else if (result.method === 'none') showToast('Unable to download automatically. Try long-pressing or screenshot.');
      else showToast('Certificate saved/shared.');
    }

    /* -----------------------
       Selfie capture & composite
       ----------------------- */
    let selfieStream = null;
    async function openSelfieOverlay() {
      $('selfieOverlay').style.display = 'flex';
      try {
        selfieStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' } });
        $('selfieVideo').srcObject = selfieStream;
      } catch (e) { showToast('Camera unavailable'); closeSelfieOverlay(); }
    }
    function closeSelfieOverlay() {
      $('selfieOverlay').style.display = 'none';
      if (selfieStream) { selfieStream.getTracks().forEach(t => t.stop()); selfieStream = null; }
    }
    $('closeSelfie')?.addEventListener('click', closeSelfieOverlay);
    $('captureSelfie')?.addEventListener('click', () => {
      const v = $('selfieVideo');
      if (!v || !v.videoWidth) { showToast('No video to capture'); return; }
      const c = document.createElement('canvas'); c.width = v.videoWidth; c.height = v.videoHeight;
      const ctx = c.getContext('2d'); ctx.drawImage(v, 0, 0, c.width, c.height);
      const data = c.toDataURL('image/png');
      closeSelfieOverlay();
      compositeSelfie(data);
    });

    // helper: convert dataURL to Blob (keeps original function name used earlier)
    function dataURLToBlob(dataURL) {
      const parts = dataURL.split(',');
      const meta = parts[0].match(/:(.*?);/);
      const mime = meta ? meta[1] : 'image/png';
      const binary = atob(parts[1]);
      const len = binary.length;
      const u8 = new Uint8Array(len);
      for (let i = 0; i < len; i++) u8[i] = binary.charCodeAt(i);
      return new Blob([u8], { type: mime });
    }

    /**
     * Fancy Instagram-ready composite
     * dataUrl: selfie image dataURL (camera)
     * opts: optional config
     *  - filter: 'none'|'warm'|'vibrant'|'bw'
     *  - format: 'square'|'4by5'|'landscape'
     *  - download: boolean (auto trigger download)
     */
    function compositeSelfie(dataUrl, opts = {}) {

      // choices for creditText
      const choices = [
        "May Maa Durga shower her divine blessings upon you today and always.",
        "May your life be filled with happiness, prosperity, and good health",
        "Wishing you a joyous and blessed Durga Puja!"
      ];

      // merge opts correctly
      opts = Object.assign({
        filter: 'vibrant',
        format: '4by5',
        download: false,
        outputPx: 1600,         // base output size for longer edge (high-res)
        circlePercent: 0.28,    // proportion of width used by selfie circle
        dh: 30,                 // margin inside frame
        fontFamily: "Genos",
        fontWeight: "400",
      }, opts || {});

      // pick credit text if not passed in
      if (!opts.creditText) {
        opts.creditText = choices[Math.floor(Math.random() * choices.length)];
      }

      // compute default font size relative to outputPx if user didn't provide one
      // tweak the multiplier (0.012 = smaller, 0.018 = medium, 0.025 = larger)
      if (!opts.fontSize) {
        opts.fontSize = Math.round(opts.outputPx * 0.012); // ~19px for 1600 base (small)
      }

      // Later, when drawing caption (replace your existing captions lines)
      const fontSize = Math.max(12, Math.round(opts.fontSize)); // safety min



      const idol = document.getElementById('idol');
      if (!idol) return showToast && showToast('idol element not found');

      // choose canvas aspect by format
      let targetW = opts.outputPx;
      let targetH;
      if (opts.format === 'square') {
        targetH = targetW;
      } else if (opts.format === '4by5') {
        targetH = Math.round(targetW * 5.2 / 4); // taller
      } else { // landscape
        targetH = Math.round(targetW * 9 / 16);
      }

      // retina scaling
      const DPR = Math.max(1, window.devicePixelRatio || 1);
      const canvas = document.createElement('canvas');
      canvas.width = targetW * DPR;
      canvas.height = targetH * DPR;
      canvas.style.width = targetW + 'px';
      canvas.style.height = targetH + 'px';
      const ctx = canvas.getContext('2d');
      ctx.scale(DPR, DPR);

      // Polaroid frame settings
      const framePadding = Math.max(24, opts.dh); // outer white margin
      const frameRadius = 18;
      const polaroidInnerW = targetW - framePadding * 2;
      const polaroidInnerH = targetH - framePadding * 2;
      const bottomCaptionHeight = Math.round(polaroidInnerH * 0.18); // thicker bottom
      const contentH = polaroidInnerH - bottomCaptionHeight;

      // Load idol image then selfie
      const idolImg = new Image();
      idolImg.crossOrigin = 'anonymous';
      idolImg.src = idol.src;

      idolImg.onload = () => {
        // Draw paper background (subtle texture color)
        ctx.fillStyle = "#0d0d0d"; // overall background (dark so polaroid pops)
        ctx.fillRect(0, 0, targetW, targetH);

        // Draw drop shadow for polaroid
        const shadowX = 18, shadowY = 18;
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,0.36)";
        roundRect(ctx, framePadding + shadowX, framePadding + shadowY, polaroidInnerW, polaroidInnerH, frameRadius);
        ctx.fill();
        ctx.restore();

        // Draw white polaroid frame
        ctx.save();
        ctx.fillStyle = "#ffffff";
        roundRect(ctx, framePadding, framePadding, polaroidInnerW, polaroidInnerH, frameRadius);
        ctx.fill();
        ctx.restore();

        // Slight paper noise underlay (subtle off-white)
        ctx.save();
        ctx.globalCompositeOperation = 'multiply';
        ctx.fillStyle = "rgba(250,250,250,0.04)";
        ctx.fillRect(framePadding, framePadding, polaroidInnerW, polaroidInnerH);
        ctx.restore();

        // Draw idol as background image inside polaroid content (cover)
        // We will fill the content area (left/top inside framePadding)
        const contentX = framePadding + 16;
        const contentY = framePadding + 16;
        const contentW = polaroidInnerW - 12;
        // place idol as cover within content area (crop to fill)
        drawImageCover(ctx, idolImg, contentX, contentY, contentW, contentH);

        // Put a subtle overlay (soft vignette) to focus center
        drawVignette(ctx, contentX, contentY, contentW, contentH, 0.6);

        // Now selfie circle placement
        const sw = Math.floor(contentW * opts.circlePercent);
        // preserve selfie aspect for circle clip - we'll fit by width
        const sx = contentX + contentW - sw - 24;
        const sy = contentY + contentH - sw - 24;

        // draw circular selfie with small border and shadow
        ctx.save();
        // shadow for the circular portrait
        ctx.beginPath();
        ctx.arc(sx + sw / 2, sy + sw / 2, sw / 2 + 8, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(0,0,0,0.28)";
        ctx.fill();
        ctx.restore();

        // clip to circle
        ctx.save();
        ctx.beginPath();
        ctx.arc(sx + sw / 2, sy + sw / 2, sw / 2, 0, Math.PI * 2);
        ctx.closePath();
        ctx.clip();

        // draw selfie (we need to load it)
        const selfie = new Image();
        selfie.crossOrigin = 'anonymous';
        selfie.src = dataUrl;
        selfie.onload = () => {
          // apply chosen filter using ctx.filter (supports modern browsers)
          ctx.save();
          // ctx.filter = filterToCanvasFilter(opts.filter);
          // draw selfie centered and cover the circle area
          ctx.filter = 'brightness(1.08) contrast(1.06)'
          drawImageCover(ctx, selfie, sx, sy, sw, sw);
          ctx.restore();

          ctx.restore(); // exit clip

          // draw thin stroke around circle
          ctx.save();
          ctx.beginPath();
          ctx.arc(sx + sw / 2, sy + sw / 2, sw / 2 + 2.5, 0, Math.PI * 2);
          ctx.strokeStyle = "rgba(255,255,255,0.95)";
          ctx.lineWidth = 5;
          ctx.stroke();
          ctx.restore();

          // draw decorative sticker top-left of polaroid content
          drawSticker(ctx, contentX + 14, contentY + 14, 120, 40);

          // film grain layer (subtle)
          applyFilmGrain(ctx, contentX, contentY, contentW, contentH, 0.06);

          // Polaroid caption area (bottom)
          ctx.save();
          ctx.fillStyle = "#f7f7f7";
          const capX = contentX;
          const capY = contentY + contentH;
          const capW = contentW;
          const capH = bottomCaptionHeight;
          ctx.fillRect(capX, capY, capW, capH);

          // caption text - credit
          ctx.fillStyle = "#222";
          const fontSize = Math.max(11, Math.round(capH * 0.22));
          ctx.font = `${opts.fontWeight} ${fontSize}px ${opts.fontFamily}`;
          ctx.textBaseline = 'middle';
          ctx.textAlign = 'center';
          const captionX = capX + capW / 2;
          const captionY = capY + capH / 2;
          // wrap if too long
          wrapText(ctx, opts.creditText, captionX, captionY, capW - 24, fontSize + 6, { align: 'center' });
          ctx.restore();

          // small watermark bottom-right (semi-transparent)
          ctx.save();
          ctx.font = `400 ${Math.round(fontSize * 0.6)}px ${opts.fontFamily}`;
          ctx.fillStyle = "rgba(0,0,0,0.18)";
          const wm = "Powered by: Minu's Robotics & Coding Center, Kishanganj";
          ctx.textAlign = 'right';
          ctx.fillText(wm, contentX + contentW - 6, capY + capH - 8);
          ctx.restore();

          // final vignette over entire canvas for mood
          globalVignette(ctx, 0.26);

          // Export
          const dataURL = canvas.toDataURL('image/png', 0.95);
          lastComposite = dataURL;
          lastCompositeBlob = dataURLToBlob(dataURL);
          // show preview (small)
          const preview = document.getElementById('selfiePreview');
          if (preview) {
            preview.innerHTML = `<img src="${dataURL}" alt="Selfie Composite" style="max-width:320px;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,0.35)">`;
          }
          if (showToast) showToast('Fancy selfie composited — ready to share!');

          // optionally auto-download
          if (opts.download) {
            const a = document.createElement('a');
            a.href = dataURL;
            a.download = `minu-selfie-${Date.now()}.png`;
            document.body.appendChild(a);
            a.click();
            a.remove();
          }
        };
        selfie.onerror = (e) => {
          if (showToast) showToast('Could not load selfie image');
          console.error(e);
        };
      };
      idolImg.onerror = (e) => {
        if (showToast) showToast('Could not load idol image');
        console.error(e);
      };

      /* ---------------- helper functions ---------------- */

      // Draw rounded rectangle
      function roundRect(ctx, x, y, w, h, r) {
        const radius = r;
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + w - radius, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
        ctx.lineTo(x + w, y + h - radius);
        ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
        ctx.lineTo(x + radius, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
      }

      // Draw image cover (like background-size: cover)
      function drawImageCover(ctx, img, x, y, w, h) {
        const iw = img.width, ih = img.height;
        if (!iw || !ih) {
          // fallback fill
          ctx.fillStyle = '#ddd';
          ctx.fillRect(x, y, w, h);
          return;
        }
        const scale = Math.max(w / iw, h / ih);
        const nw = iw * scale;
        const nh = ih * scale;
        const cx = (w - nw) / 2;
        const cy = (h - nh) / 2;
        ctx.drawImage(img, x + cx, y + cy, nw, nh);
      }

      // small sticker (you can replace by drawing an image)
      function drawSticker(ctx, x, y, w, h) {
        // rounded colored sticker
        ctx.save();
        roundRect(ctx, x, y, w, h, 12);
        ctx.fillStyle = "#ffd54a";
        ctx.fill();
        // text
        ctx.fillStyle = "#1b1b1b";
        ctx.font = `600 ${Math.max(12, Math.round(h * 0.45))}px ${opts.fontFamily}`;
        ctx.textBaseline = 'middle';
        ctx.textAlign = 'center';
        ctx.fillText("Jai Ma Durga", x + w / 2, y + h / 2);
        ctx.restore();
      }

      // film grain by drawing many small semi-random shapes (cheap)
      function applyFilmGrain(ctx, x, y, w, h, intensity = 0.04) {
        const alpha = Math.max(0.01, Math.min(0.12, intensity));
        const count = Math.round((w * h) * (alpha * 0.0009));
        const imgData = ctx.getImageData(x, y, w, h);
        for (let i = 0; i < count; i++) {
          const rx = Math.floor(Math.random() * w);
          const ry = Math.floor(Math.random() * h);
          const off = ((ry * w) + rx) * 4;
          const v = (Math.random() * 40 - 20) | 0;
          imgData.data[off] = clamp(imgData.data[off] + v, 0, 255);
          imgData.data[off + 1] = clamp(imgData.data[off + 1] + v, 0, 255);
          imgData.data[off + 2] = clamp(imgData.data[off + 2] + v, 0, 255);
          // alpha kept
        }
        ctx.putImageData(imgData, x, y);
      }

      function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

      // draw soft vignette for content box
      function drawVignette(ctx, x, y, w, h, darkness = 0.55) {
        const cx = x + w / 2, cy = y + h / 2;
        const rx = w * 0.6, ry = h * 0.6;
        const grad = ctx.createRadialGradient(cx, cy, Math.min(w, h) * 0.05, cx, cy, Math.max(rx, ry));
        grad.addColorStop(0, 'rgba(0,0,0,0)');
        grad.addColorStop(0.7, `rgba(0,0,0,${darkness * 0.45})`);
        grad.addColorStop(1, `rgba(0,0,0,${darkness})`);
        ctx.save();
        ctx.globalCompositeOperation = 'multiply';
        ctx.fillStyle = grad;
        ctx.fillRect(x, y, w, h);
        ctx.restore();
      }

      // global vignette across canvas
      function globalVignette(ctx, darkness = 0.5) {
        const w = targetW, h = targetH;
        const grad = ctx.createRadialGradient(w / 2, h / 2, Math.min(w, h) * 0.3, w / 2, h / 2, Math.max(w, h));
        grad.addColorStop(0, 'rgba(0,0,0,0)');
        grad.addColorStop(0.8, `rgba(0,0,0,${darkness * 0.25})`);
        grad.addColorStop(1, `rgba(0,0,0,${darkness * 0.6})`);
        ctx.save();
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, w, h);
        ctx.restore();
      }

      // convert logical filter code to canvas filter string
      function filterToCanvasFilter(name) {
        switch ((name || '').toLowerCase()) {
          case 'warm':
            // slightly warm + boost contrast
            return 'contrast(1.08) saturate(1.06) sepia(0.12) hue-rotate(-6deg)';
          case 'vibrant':
            return 'contrast(1.08) saturate(1.18) brightness(1.02)';
          case 'bw':
          case 'mono':
            return 'grayscale(1) contrast(1.05)';
          default:
            return 'none';
        }
      }

      // wrapText - center or left aligned multiline text
      function wrapText(ctx, text, x, y, maxWidth, lineHeight, opts = {}) {
        opts = Object.assign({ align: 'left' }, opts);
        const words = text.split(' ');
        let line = '';
        const lines = [];
        for (let n = 0; n < words.length; n++) {
          const testLine = line + words[n] + ' ';
          const metrics = ctx.measureText(testLine);
          if (metrics.width > maxWidth && n > 0) {
            lines.push(line.trim());
            line = words[n] + ' ';
          } else {
            line = testLine;
          }
        }
        lines.push(line.trim());
        const totalH = lines.length * lineHeight;
        let startY = y - totalH / 2 + lineHeight / 2;
        for (let i = 0; i < lines.length; i++) {
          const tx = x;
          ctx.textAlign = opts.align;
          ctx.fillText(lines[i], tx, startY + i * lineHeight);
        }
      }
    }


    /* -----------------------
       Orientation helper
       ----------------------- */
    function checkOrientation() {
      if (window.innerHeight > window.innerWidth) $('orientationOverlay').style.display = 'flex';
      else $('orientationOverlay').style.display = 'none';
    }
    window.addEventListener('resize', checkOrientation);
    window.addEventListener('orientationchange', checkOrientation);

    /* -----------------------
       Mode switching & wiring buttons
       ----------------------- */
    function setMode(m) {
      mode = m;
      // update UI & render hotspots
      renderHotspots();
      updateProgress();
    }

    function wireButtons() {
      // Desktop controls
      $('modeSawari')?.addEventListener('click', () => setMode('sawari'));
      $('modeWeapons')?.addEventListener('click', () => setMode('weapons'));
      $('modeGods')?.addEventListener('click', () => setMode('gods'));
      $('modeDemons')?.addEventListener('click', () => setMode('demons'));
      $('downloadCert')?.addEventListener('click', () => downloadCertificate());
      // Mobile overlay buttons -> call same functions
      $('modeSawari_mobile')?.addEventListener('click', () => setMode('sawari'));
      $('modeWeapons_mobile')?.addEventListener('click', () => setMode('weapons'));
      $('modeGods_mobile')?.addEventListener('click', () => setMode('gods'));
      $('downloadCert_mobile')?.addEventListener('click', () => downloadCertificate());
      // Selfie / share wiring (desktop and mobile)
      $('selfieBtn')?.addEventListener('click', () => openSelfieOverlay());
      $('selfieBtn_mobile')?.addEventListener('click', () => openSelfieOverlay());
      $('shareBtn')?.addEventListener('click', async () => {
        if (!lastCompositeBlob) return showToast('Take a selfie first');
        const res = await saveBlobAsFile(lastCompositeBlob, 'selfie_overlay.png');
        if (res.method === 'open') showToast('Opened in new tab — long-press to save');
        else if (res.method === 'none') showToast('Unable to download automatically');
        else showToast('Saved/Shared');
      });
      $('shareBtn_mobile')?.addEventListener('click', async () => {
        if (!lastCompositeBlob) return showToast('Take a selfie first');
        const res = await saveBlobAsFile(lastCompositeBlob, 'selfie_overlay.png');
        if (res.method === 'open') showToast('Opened in new tab — long-press to save');
        else if (res.method === 'none') showToast('Unable to download automatically');
        else showToast('Saved/Shared');
      });
    }

    /* -----------------------
       Init: load hotspots.json then start
       ----------------------- */
    async function init() {
      updateVoiceIndicator();
      wireButtons();
      checkOrientation();

      // render once even if hotspots empty (keeps UI responsive)
      renderHotspots();
      updateProgress();
    }

    /* Load hotspots.json and then init */
    fetch('assets/hotspots.json')
      .then(r => {
        if (!r.ok) throw new Error('hotspots.json load failed: ' + r.status);
        return r.json();
      })
      .then(j => { HOTSPOTS = j || {}; init(); })
      .catch(e => { console.warn(e); HOTSPOTS = {}; init(); showToast('hotspots.json failed to load (check console)'); });

    /* expose a couple functions for debugging */
    window.setMode = setMode;
    window.openSelfieOverlay = openSelfieOverlay;
  </script>
</body>

</html>